<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TMT-A Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            position: relative;
            overflow: hidden;
        }

        #container {
            width: 900px;
            height: 600px;
            position: relative;
            border: 1px solid #ccc;
        }

        .circle {
            width: 55px;
            height: 55px;
            background-color: lightblue;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            cursor: pointer;
            font-size: 20px;
            transition: background-color 0.3s;
        }

        .correct {
            background-color: green !important;
        }

        .incorrect {
            background-color: red !important;
        }
    </style>
</head>

<body>
    <h1>TMT-A Test</h1>
    <div id="container">
        <canvas id="mouseCanvas" width="900" height="600"></canvas>
    </div>
    <p id="result"></p>
    <p id="errorCount"></p> <!-- display the number of wrong click -->

    <script>
        let currentNum = 1;
        let startTime;
        let incorrectClicks = 0; // counter for wrong clicks
        let mousePath = [];
        const canvas = document.getElementById('mouseCanvas');
        const ctx = canvas.getContext('2d');

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        // shuffle the number; fisher-yates algo

        function isOverlapping(x, y, circles) {
            for (let i = 0; i < circles.length; i++) {
                const circleX = circles[i].offsetLeft + circles[i].offsetWidth / 2;
                const circleY = circles[i].offsetTop + circles[i].offsetHeight / 2;
                const distance = Math.sqrt(Math.pow(x - circleX, 2) + Math.pow(y - circleY, 2));
                if (distance < 120) {
                    return true;
                }
            }
            return false;
        }
        // calculating distance

        function generateCircles() {
            const container = document.getElementById('container');
            const numbers = Array.from({ length: 25 }, (_, i) => i + 1);
            shuffle(numbers);

            numbers.forEach(num => {
                const circle = document.createElement('div');
                circle.className = 'circle';
                circle.textContent = num;

                let x, y;
                do {
                    x = Math.random() * (container.clientWidth - 60);
                    y = Math.random() * (container.clientHeight - 60);
                } while (isOverlapping(x, y, document.querySelectorAll('.circle')));

                circle.style.left = `${x}px`;
                circle.style.top = `${y}px`;
                circle.onclick = () => handleClick(num, circle);
                container.appendChild(circle);
            });
        }

        function handleClick(num, circle) {
            if (num === currentNum) {
                document.querySelectorAll('.incorrect').forEach(incorrectCircle => {
                    incorrectCircle.classList.remove('incorrect');
                    incorrectCircle.style.backgroundColor = 'lightblue';
                });

                circle.classList.add('correct');

                if (num === 1) {
                    startTime = new Date();
                }
                if (num === 25) {
                    const endTime = new Date();
                    const totalTime = (endTime - startTime) / 1000;
                    document.getElementById('result').textContent = `Test completed in ${totalTime.toFixed(2)} seconds`;
                    document.getElementById('errorCount').textContent = `Number of incorrect clicks: ${incorrectClicks}`;
                    document.querySelectorAll('.circle').forEach(circle => circle.style.visibility = 'hidden');

                    const previousResults = JSON.parse(localStorage.getItem('tmtaResults')) || [];
                    previousResults.push({ time: totalTime, errors: incorrectClicks, date: new Date().toISOString() });
                    localStorage.setItem('tmtaResults', JSON.stringify(previousResults));

                    saveMousePathAsImage();
                }
                currentNum += 1;
            } else {
                circle.classList.add('incorrect');
                incorrectClicks += 1;
            }
        }

        function saveMousePathAsImage() {
            // draw mouse-path
            ctx.beginPath();
            ctx.moveTo(mousePath[0].x, mousePath[0].y);
            for (let i = 1; i < mousePath.length; i++) {
                ctx.lineTo(mousePath[i].x, mousePath[i].y);
            }
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            ctx.stroke();

            // save picture
            const image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
            const link = document.createElement('a');
            link.download = 'mouse_path.png';
            link.href = image;
            link.click();
        }

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            mousePath.push({ x, y });
        });

        generateCircles();
    </script>
</body>

</html>